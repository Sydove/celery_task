消息是信息的载体，用于在生产者和消费者之间传递。属性是对消息进行修饰，比如消息的优先级，延迟等高级特性，主体则就是消息体的内容。

### 消息的属性

AMQP消息可以具有多个属性，这些属性提供了有关消息的元数据信息。以下是一些常见的消息属性：

* **Message ID（消息标识）：** 一个唯一的标识符，用于标识消息。

* **Timestamp（时间戳）：** 指定消息创建的时间。

* **Type（消息类型）：** 用于描述消息的类型，例如 "order", "payment", 等。

* **Content Type（内容类型）：** 指定消息体的MIME类型，例如 "application/json"。

* **Content Encoding（内容编码）：** 指定消息体的编码方式，例如 "gzip"。

* **User ID（用户标识）：** 指定消息的创建者或拥有者的用户标识。

* **App ID（应用标识）：** 指定创建消息的应用程序。

* **Delivery Mode（投递模式）：** 指定消息的持久性，可以是持久的（将消息保存到磁盘）或非持久的。消息的持久化需要配合路由/队列都要持久化使用.消息的持久化会对性能有所影响.

* **Priority（优先级）：** 指定消息的优先级。

* **Expiration（过期时间）：** 指定消息的有效期，超过该时间未被消费则被认为是过期。



### 消息的确认机制

AMQP消息确认机制是确保消息被正确处理和传递的一种机制，它包括两个主要概念：消息确认（acknowledgment）和消息拒绝（nacknowledgment）。

1. **消息确认（Acknowledgment）**：当消费者成功处理一条消息时，它会向消息代理发送一个确认，表示消息已经被正确地接收和处理。消息代理在收到确认后会从队列中删除该消息。
2. **消息拒绝（Nacknowledgment）**：如果消息代理无法将消息正确地路由到队列，或者消费者无法处理消息并希望消息被重新排队，它可以发送一个拒绝消息的确认（nacknowledgment）。这使得消息代理可以根据配置将消息重新放回队列，或者将消息标记为死信。



**两种消息的确认模式**

- **自动确认（Automatic Acknowledgment）**：消息代理立即将消息标记为已接收，而不等待消费者确认。这种模式下，一旦消息被发送给消费者，消息代理就会将其标记为已接收，并将其从队列中删除。这种模式下可能导致消息在传递过程中丢失，因为在消费者处理消息之前就确认了消息。
- **手动确认（Manual Acknowledgment）**：消费者在处理消息后，明确地向消息代理发送确认。这样，只有在消息被成功处理后才会被删除。这种模式下可以确保消息在传递过程中不会丢失，因为只有在消息被成功处理后才会被删除。



### 消息避免重复消费

1. **消息去重（Message Deduplication）**：
   - **唯一标识符：** 生产者在发送消息时为每个消息生成一个唯一标识符，并在消费者端维护一个已经处理过的消息标识符列表。在处理消息前，先检查该消息的唯一标识符是否已经存在，如果存在则认为该消息是重复的，不再进行处理。
   - **消息存储：** 消费者可以将已经处理过的消息的唯一标识符存储在持久化存储中，比如数据库。这样，就可以跨越系统重启等情况保持消息去重状态。
2. **消息过期时间（Message Expiry）**：
   - 给每个消息设置一个过期时间，确保消息在一定时间内被成功处理，否则认为消息已经过期。这样可以避免消息一直在队列中等待被消费而导致重复消费。
3. **幂等性操作（Idempotent Operations）**：
   - 消费者的处理逻辑设计成幂等的，即多次处理同一消息的效果和一次处理的效果相同。这样，哪怕消息被重复消费，系统的状态也不会发生变化。
4. **事务性消息（Transactional Messaging）**：
   - 使用事务性消息来确保消息的原子性。如果消息的处理是一个事务，那么在事务成功提交之前，消息代理会将消息标记为“未消费”，如果事务回滚，则消息会被重新放回队列。这样可以确保消息在处理失败时不会被认为已经被消费。
5. **消息状态管理**：
   - 维护消息的处理状态，例如使用一个状态机，确保消息只能从未处理状态转变为已处理状态。这可以通过在消息体中添加状态信息或在外部存储中维护状态信息来实现。