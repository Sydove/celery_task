消息，服务与应用程序之间传送的数据，由Properties（属性）和body（主体）组成。

属性是对消息进行修饰，比如消息的优先级，延迟等高级特性，主体则就是消息体的内容。

消息属性：

Content type（内容类型）
Content encoding（内容编码）
Routing key（路由键）
Delivery mode (persistent or not)
投递模式（持久化 或 非持久化）
Message priority（消息优先权）
Message publishing timestamp（消息发布的时间戳）
Expiration period（消息有效期）
Publisher application id（发布应用的 ID）
消息主体：
AMQP 的消息除属性外，也含有一个有效载荷Payload（消息实际携带的数据），它被 AMQP 代理当作不透明的字节数组来对待。

消息代理不会检查或者修改有效载荷。消息可以只包含属性而不携带有效载荷。它通常会使用类似 JSON 这种序列化的格式数据，为了节省，协议缓冲器和MessagePack将结构化数据序列化，以便以消息的有效载荷的形式发布。AMQP及其同行者们通常使用 “content-type” 和 “content-encoding” 这两个字段来与消息沟通进行有效载荷的辨识工作，但这仅仅是基于约定而已。

消息持久化：
消息能够以持久化的方式发布，AMQP 代理会将此消息存储在磁盘上。如果服务器重启，系统会确认收到的持久化消息未丢失。

简单地将消息发送给一个持久化的交换机或者路由给一个持久化的队列，并不会使得此消息具有持久化性质：消息的持久性完全取决与消息本身的持久模式（persistence mode）。

将消息以持久化方式发布时，会对性能造成一定的影响。
————————————————
版权声明：本文为CSDN博主「骑个小蜗牛」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/JokerLJG/article/details/123007557





AMQP消息机制
消息确认
消费者在处理消息的时候偶尔会失败或者有时会直接崩溃掉。而且网络原因也有可能引起各种问题。
这就给我们出了个难题，AMQP代理在什么时候删除消息才是正确的。

AMQP的两种消息确认模式：

自动确认模式：当消息中间件将消息发送给消费者后立即删除。（使用AMQP方法：basic.deliver 或 basic.get-ok)
显式确认模式：待消费者发送一个确认回执（acknowledgement）后再删除消息。（使用AMQP方法：basic.ack）
如果一个消费者在尚未发送确认回执的情况下挂掉了，那 AMQP 代理会将消息重新投递给另一个消费者。如果当时没有可用的消费者了，消息代理会死等下一个注册到此队列的消费者，然后再次尝试投递。

拒绝消息
当一个消费者接收到某条消息后，处理过程有可能成功，有可能失败。消费者可以向消息代理（消息中间件）表明，本条消息由于 “拒绝消息” 的原因处理失败了（或者未能在此时完成）。
当拒绝某条消息时，消费者可以告诉消息代理如何处理这条消息——销毁它或者重新放入队列。

当此队列只有一个消费者时，请确认不要由于拒绝消息并且选择了重新放入队列的行为而引起消息在同一个消费者身上无限循环的情况发生。

在AMQP 中，basic.reject 方法用来执行拒绝消息的操作。但 basic.reject 有个限制：你不能使用它决绝多个带有确认回执（acknowledgements）的消息。但是如果你使用的是 RabbitMQ，那么你可以使用被称作 negative acknowledgements（也叫 nacks）的 AMQP 0-9-1 扩展来解决这个问题。
————————————————
版权声明：本文为CSDN博主「骑个小蜗牛」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/JokerLJG/article/details/123007557